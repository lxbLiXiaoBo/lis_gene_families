#!/usr/bin/env perl


#use strict;
use warnings;
use Getopt::Long; # get the command line options
use Pod::Usage; # so the user knows what's going on
use DBI; # our database interface


=head1 NAME

gmod_mrna_and_peptide_uniquename2name.pl - Changes the uniquename field to the value of the name field for mRNA's if they don't match. Dito for polypeptides, unless both fields are autogenerated, then the values are taken from the polypeptide's mRNA.

=head1 SYNOPSIS

  gmod_mrna_and_peptide_uniquename2name.pl [options]

  --organismid  The organism_id from the organism table if only one organism is desired
  --dbname      The name of the chado database (default=chado)
  --username    The username to access the database with (default=chado)
  --password    The password to log into the database with
  --host        The host the database is on (default=localhost)
  --port        The port the database is on
  --dbid        Prevents the creation of dbxref entries
  --nomrna      Prevent mRNA names from being updated
  --nopoly      Prevent polypeptide names from being updated

=head1 DESCRIPTION

If the --dbid flag is given then a dbxref will be create for each non-autogenerated uniquename value that is going to be overwritten, i.e. PAC ids.

Note that the script appends "_pep" onto the end of each polypeptide name and uniquename value. This is to preserve the uniqueness requirement of the unqiename field while assigning polypeptides the same names as their mRNAs. This script also adds "_pep" to polypeptides in the database whose name and uniquename values already match.

=head1 AUTHOR

Alan Cleary

Copyright (c) 2013
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=cut


# see if the user nees help
my $man = 0;
my $help = 0;
GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;


# get the command line optinos
my ($organism, $port, $db, $nomrna, $nopoly);
$port = $ENV{CHADO_DB_PORT} = ($ENV{CHADO_DB_PORT});
my $dbname = "chado";
$dbname = $ENV{CHADO_DB_NAME} if ($ENV{CHADO_DB_NAME});
my $username = "chado";
$username = $ENV{CHADO_DB_USER} if ($ENV{CHADO_DB_USER});
my $password = "";
$password = $ENV{CHADO_DB_PASS} if ($ENV{CHADO_DB_PASS});
my $host = "localhost";
$host = $ENV{CHADO_DB_HOST} if ($ENV{CHADO_DB_HOST});

GetOptions("organismid=i"   => \$organism,
           "dbname=s"       => \$dbname,
           "username=s"     => \$username,
           "password=s"     => \$password,
           "host=s"         => \$host,
           "port=i"         => \$port,
           "dbid=i"         => \$db,
           "nomrna"         => \$nomrna,
           "nopoly"         => \$nopoly) || die("Error in command line arguments\n");


# make sure there weren't any unexpected command line arguments
if (@ARGV > 0) {
    pod2usage(2);
}


# set the organism variable for queries (note: we are assuming that the feature table will be denoted by f in the queries)
$organism = ($organism) ? "AND f.organism_id=" . $organism : "";


# create a data source name
my $dsn = "dbi:Pg:dbname=$dbname;host=$host;";
$dsn .= "port=$port;" if $port;


# connect to the database
my $conn = DBI->connect($dsn, $username, $password, {'RaiseError' => 1});


# if mRNAs should be updated
if (!$nomrna) {
    # get the cvterm for mRNA
    my $mrna = $conn->selectrow_array("SELECT cvterm_id FROM cvterm WHERE name LIKE 'mRNA';");
    
    
    # get all the features whose name doesn't contain auto and whose uniquename doesn't match the uniquename or all features whose name doesn't contain auto and uniqiename does contain auto
    my $query = $conn->prepare(
        "SELECT f.feature_id,f.uniquename " .
        "FROM feature f " .
        "WHERE f.type_id=$mrna $organism AND " .
        "((f.uniquename SIMILAR TO 'auto' AND f.name NOT SIMILAR TO 'auto') OR " .
        "(f.name NOT SIMILAR TO 'auto' AND f.name != f.uniquename));"
        );
    $query->execute();
    
    
    # report how many mRNAs can be updated
    my $num_mrnas = $query->rows;
    print "$num_mrnas mRNAs to be updated\n";
    if ($num_mrnas > 0) {
        print "Updating...\n";
    }
    
    
    # update the uniquenames
    my @lemonade = (); # mRNAs that need a dbxref and whose polypeptide(s) need to be updated
    my @lemons = (); # mRNAs that couldn't be updated - probably because a feature already existed with the same uniquename
    while (my @row = $query->fetchrow_array()) {
        my ($feature_id, $uniquename) = @row;
        # if we succesfully updated the feature
        if ($conn->do("UPDATE feature SET uniquename=name WHERE feature_id=$feature_id;")) {
            push(@lemonade, $feature_id); # perhaps the user will want to know which mrna's were successfully updated
            #$lemonade{$feature_id} = 1;
            # if the uniquename wasn't autogenerated and an id for a db was given create a dbxref for it
            if (index($uniquename, "auto") == -1 && $db) {
                # check to see if a dbx entry akready exists
                my $dbxref = $conn->selectrow_array("SELECT dbxref_id FROM dbxref WHERE db_id=$db AND accession='$uniquename' AND version='1';");
                if ($dbxref) {
                    # one exists, check if a feature_dbxref already exists
                    my $featurexref = $conn->selectrow_array("SELECT feature_dbxref_id FROM feature_dbxref WHERE feature_id=$feature_id AND dbxref_id=$dbxref;");
                    if ($featurexref) {
                        # the feature_dbxref exists, lets set the primary dbxref of the feature just for giggles
                        if (!$conn->do("UPDATE feature SET dbxref_id=$dbxref WHERE feature_id=$feature_id;")) {
                            print "Failed to update the primary dbxref to $dbxref from an existing feature_dbxref for feature $feature_id\n";
                        }
                    }
                    else {
                        # the feature_dbxref does not exist, let's create one
                        if ($conn->do("INSERT INTO feature_dbxref (feature_id, dbxref_id) VALUES ($feature_id, $dbxref);")) {
                            # now we'll make the dbxref the primary dbxref for the feature
                            if (!$conn->do("UPDATE feature SET dbxref_id=$dbxref WHERE feature_id=$feature_id;")) {
                                print "Failed to update the primary dbxref to $dbxref for feature $feature_id\n";
                            }
                        }
                        else {
                            print "Failed to add feature_dbxref for feature $feature_id and dbxref $dbxref\n";
                        }
                    }
                }
                else {
                    # create a new dbxref entry if one doesn't exist
                    if ($conn->do("INSERT INTO dbxref (db_id, accession, version) VALUES ($db, '$uniquename', '1');")) {
                        # get the new entry's id
                        $dbxref = $conn->selectrow_array("SELECT dbxref_id FROM dbxref WHERE db_id=$db AND accession='$uniquename' AND version='1';");
                        # create a feature_dbxref entry for the new dbxref
                        if ($conn->do("INSERT INTO feature_dbxref (feature_id, dbxref_id) VALUES ($feature_id, $dbxref);")) {
                            # update the feature's primary dbxref to be the new one
                            if (!$conn->do("UPDATE feature SET dbxref_id=$dbxref WHERE feature_id=$feature_id;")) {
                                print "Failed to update primary dbxref to $dbxref for feature $feature_id\n";
                            }
                        }
                        else {
                            print "Failed to add feature_dbxref entry for feature $feature_id and dbxref $dbxref\n";
                        }
                    }
                    else {
                        print "Failed to create dbxref for feature $feature_id\n";
                    }
                }
            }
        }
        else {
            push(@lemons, $feature_id); # perhaps the user will want to know which mrna's were not updated
            #$lemons{$feature_id} = 1;
        }
    }
    
    
    # report how many mRNAs were changed and how many were not
    print "", scalar(@lemonade), " mRNAs were successfully updated\n", scalar(@lemons), " failed to update\n";
}

# check if polypeptides should be updated
if (!$nopoly) {
    print "Updating polypeptides\n";
    # get the cvterm for polypeptide
    my $polypeptide = $conn->selectrow_array("SELECT cvterm_id FROM cvterm WHERE name LIKE 'polypeptide';");
    if (!$polypeptide) {
        die("Failed to retrieve polypeptide cvterm\n");
    }

    # update the polypeptides
    my @sweet = ();
    my @sour = ();
    # get all the polypeptide features whose name and/or uniquename contain auto or they don't contain _pep
    my $query = $conn->prepare("SELECT feature_id, name, uniquename " .
                            "FROM feature WHERE type_id=$polypeptide $organism " .
                            "AND (name LIKE '%auto%' OR uniquename LIKE '%auto%' OR uniquename NOT LIKE '%_pep%');");
    $query->execute();
    
    # report how many polypeptides can be updated
    my $num_polypeptides = $query->rows;
    print "$num_polypeptides polypeptidess to be updated\n";
    if ($num_polypeptides > 0) {
        print "Updating...\n";
    }

    # process them
    while (my @row = $query->fetchrow_array()) {
        my ($feature, $name, $uniquename) = @row;
        # if the name is auto generated then pull the name from the polypeptide's mRNA
        if (index($name, "auto") != -1) {
            my $parent = $conn->selectrow_array("SELECT f.name FROM feature f, feature_relationship fr WHERE f.feature_id=fr.object_id AND fr.subject_id=$feature;");
            # then it needs _pep as well.. we'll check just in case though
            $parent .= "_pep" if (index($name, "_pep") == -1);
            if ($conn->do("UPDATE feature SET name='$parent', uniquename='$parent' WHERE feature_id=$feature;")) {
                push(@sweet, $feature);
            }
            else { push(@sour, $feature); };
        }
        # if the uniquename is autogenerated but the name is not, set the uniquename to the name value
        elsif (index($name, "auto") == -1 and index($uniquename, "auto") != -1) {
            # then uniquename maybe they need _pep as well
            $name .= "_pep" if (index($name, "_pep") == -1);
            if ($conn->do("UPDATE feature SET name='$name', uniquename='$name' WHERE feature_id=$feature;")) {
                push(@sweet, $feature);
            }
            else { push(@sour, $feature); };
        }
        # neither name or uniquename are autogenerated
        else {
            $name .= "_pep" if (index($name, "_pep") == -1);
            # if uniquename is not the same as name then it should be preserved in a dbxref, provided we have a db_id
            if ($dbid and $name ne $uniquename) {
                $conn->do("INSERT INTO dbxref (db_id, accession) VALUES ($dbid, '$uniquename');");
                my $dbxref = $conn->selectrow_array("SELECT dbxref_id FROM dbxref ORDER BY dbxref_id DESC LIMIT 1;");
                if ($conn->do("UPDATE feature SET dbxref_id=$dbxref, name='$name', uniquename='$name' WHERE feature_id=$feature;")) {
                    push(@sweet, $feature);
                }
                else { push(@sour, $feature); };
            }
            else {
                if ($conn->do("UPDATE feature SET name='$name', uniquename='$name' WHERE feature_id=$feature;")) {
                    push(@sweet, $feature);
                }
                else { push(@sour, $feature); };
            }
        }
    }


    # report how mny polypeptides were updated
    print "", scalar(@sweet), " polypeptides were succesfully updated\n", scalar(@sour), " failed to update\n";
}


# close the database connection
$conn->disconnect();

