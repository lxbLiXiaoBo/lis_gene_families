#!/usr/bin/env perl

#use strict;
use warnings;
use Getopt::Long; # get the command line options
use DBI; # our database interface

=head1 NAME

 $0 - Changes the uniquename column of mRNA's with non-autoassigned names to their name value if they don't match. The uniquename and name values are also given to the polypeptides associated with each mRNA. This allows data from fasta files to be loaded into the database [hopefully] without preprocessing, preserving meaningful names.

=head1 SYNOPSIS

  % gmod_mrna_uniquename2name.pl [options]

=head1 COMMAND-LINE OPTIONS

  --organismid  The organism_id from the organism table if only one organism is desired
  --dbname      The name of the chado database (default=chado)
  --username    The username to access the database with (default=chado)
  --password    The password to log into the database with
  --host        The host the database is on (default=localhost)
  --port        The port the database is on
  --dbid        Prevents the creation of dbxref entries
  --nopoly      Prevent the name from being extended to polypeptides

=head1 DESCRIPTION

The script is written for use with a PostGreSQL database.

By default the script creates a dbxref entry for each unique id that was overwritten whose value was not autogenerated by the loader. This behavior can be prevented with the --nodbxref option.

Also by default, the script gives the uniquename and name values to the polypeptides associated with each mRNA when autoassigned values are present. "_poly" is appended to each value to preserve uniqueness. This behavior can be prevented with the --nopoly flag.

=head1 AUTHOR

Alan Cleary

Copyright (c) 2013
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=cut


# get the command line optinos
my ($organism, $port, $db, $nopoly);
$port = $ENV{CHADO_DB_PORT} = ($ENV{CHADO_DB_PORT});
my $dbname = "chado";
$dbname = $ENV{CHADO_DB_NAME} if ($ENV{CHADO_DB_NAME});
my $username = "chado";
$username = $ENV{CHADO_DB_USER} if ($ENV{CHADO_DB_USER});
my $password = "";
$password = $ENV{CHADO_DB_PASS} if ($ENV{CHADO_DB_PASS});
my $host = "localhost";
$host = $ENV{CHADO_DB_HOST} if ($ENV{CHADO_DB_HOST});

GetOptions("organismid=i"   => \$organism,
           "dbname=s"       => \$dbname,
           "username=s"     => \$username,
           "password=s"     => \$password,
           "host=s"         => \$host,
           "port=i"         => \$port,
           "dbid=i"         => \$db,
           "nopoly"         => \$nopoly) || die("Error in command line arguments\n");

# make sure there weren't any unexpected command line arguments
if (@ARGV > 0) {
    die("Unexpected argument\nUsage: gmod_mrna_uniquename2name.pl [options]\n");
}

# set the organism variable for queries (note: we are assuming that the feature table will be denoted by f in the queries)
$organism = ($organism) ? "AND f.organism_id=" . $organism : "";

# create a data source name
my $dsn = "dbi:Pg:dbname=$dbname;host=$host;";
$dsn .= "port=$port;" if $port;

# connect to the database
my $conn = DBI->connect($dsn, $username, $password, {'RaiseError' => 1});

# get the cvterm for mRNA
my $mrna = $conn->selectrow_array("SELECT cvterm_id FROM cvterm WHERE name LIKE 'mRNA';");

# get all the features whose name doesn't contain auto and whose uniquename doesn't match the uniquename or all features whose name doesn't contain auto and uniqiename does contain auto
my $query = $conn->prepare(
    "SELECT f.feature_id,f.uniquename " .
    "FROM feature f " .
    "WHERE f.type_id=$mrna $organism AND " .
    "((f.uniquename SIMILAR TO 'auto' AND f.name NOT SIMILAR TO 'auto') OR " .
    "(f.name NOT SIMILAR TO 'auto' AND f.name != f.uniquename));"
    );
$query->execute();

# report how many mRNAs can be updated
my $num_mrnas = $query->rows;
print "$num_mrnas mRNAs to be updated\n";
if ($num_mrnas == 0) {
    die("No need to continue execution\nExiting...\n");
}
else {
    print "Updating...\n";
}

# update the uniquenames
my @lemonade = (); # mRNAs that need a dbxref and whose polypeptide(s) need to be updated
my @lemons = (); # mRNAs that couldn't be updated - probably because a feature already existed with the same uniquename
#my (%lemonade, %lemons);
while (my @row = $query->fetchrow_array()) {
    my ($feature_id, $uniquename) = @row;
    # if we succesfully updated the feature
    if ($conn->do("UPDATE feature SET uniquename=name WHERE feature_id=$feature_id;")) {
        push(@lemonade, $feature_id); # perhaps the user will want to know which mrna's were successfully updated
        #$lemonade{$feature_id} = 1;
        # if the uniquename wasn't autogenerated and an id for a db was given create a dbxref for it
        if (index($uniquename, "auto") == -1 && $db) {
            # check to see if a dbx entry akready exists
            my $dbxref = $conn->selectrow_array("SELECT dbxref_id FROM dbxref WHERE db_id=$db AND accession='$uniquename' AND version='1';");
            if ($dbxref) {
                # one exists, check if a feature_dbxref already exists
                my $featurexref = $conn->selectrow_array("SELECT feature_dbxref_id FROM feature_dbxref WHERE feature_id=$feature_id AND dbxref_id=$dbxref;");
                if ($featurexref) {
                    # the feature_dbxref exists, lets set the primary dbxref of the feature just for giggles
                    if (!$conn->do("UPDATE feature SET dbxref_id=$dbxref WHERE feature_id=$feature_id;")) {
                        print "Failed to update the primary dbxref to $dbxref from an existing feature_dbxref for feature $feature_id\n";
                    }
                }
                else {
                    # the feature_dbxref does not exist, let's create one
                    if ($conn->do("INSERT INTO feature_dbxref (feature_id, dbxref_id) VALUES ($feature_id, $dbxref);")) {
                        # now we'll make the dbxref the primary dbxref for the feature
                        if (!$conn->do("UPDATE feature SET dbxref_id=$dbxref WHERE feature_id=$feature_id;")) {
                            print "Failed to update the primary dbxref to $dbxref for feature $feature_id\n";
                        }
                    }
                    else {
                        print "Failed to add feature_dbxref for feature $feature_id and dbxref $dbxref\n";
                    }
                }
            }
            else {
                # create a new dbxref entry if one doesn't exist
                if ($conn->do("INSERT INTO dbxref (db_id, accession, version) VALUES ($db, '$uniquename', '1');")) {
                    # get the new entry's id
                    $dbxref = $conn->selectrow_array("SELECT dbxref_id FROM dbxref WHERE db_id=$db AND accession='$uniquename' AND version='1';");
                    # create a feature_dbxref entry for the new dbxref
                    if ($conn->do("INSERT INTO feature_dbxref (feature_id, dbxref_id) VALUES ($feature_id, $dbxref);")) {
                        # update the feature's primary dbxref to be the new one
                        if (!$conn->do("UPDATE feature SET dbxref_id=$dbxref WHERE feature_id=$feature_id;")) {
                            print "Failed to update primary dbxref to $dbxref for feature $feature_id\n";
                        }
                    }
                    else {
                        print "Failed to add feature_dbxref entry for feature $feature_id and dbxref $dbxref\n";
                    }
                }
                else {
                    print "Failed to create dbxref for feature $feature_id\n";
                }
            }
        }
    }
    else {
        push(@lemons, $feature_id); # perhaps the user will want to know which mrna's were not updated
        #$lemons{$feature_id} = 1;
    }
}

# report how many mRNAs were changed and how many were not
print "", scalar(@lemonade), " mRNAs were successfully updated\n", scalar(@lemons), " failed to update\n";
#my $count = 0;
#foreach my $id (keys %lemonade) {
#    ++count;
#    print "$lemonade{$id}\n";
#}
#print "$count\n";
#$count = 0;
#foreach my $id (keys %lemons) {
#    ++count;
#    print "$lemons{$id}\n";
#}
#print "$count\n";

# check if polypeptides should be updated
if (!$nopoly) {
    print "Updating polypeptides\n";
    # get te cvterm for polypeptide
    my $polypeptide = $conn->selectrow_array("SELECT cvterm_id FROM cvterm WHERE name LIKE 'polypeptide';");
    # update the polypeptides
    my @sweet = ();
    my @sour = ();
    foreach my $glass (@lemonade) {
        # get the polypeptide(s) associated with each mRNA
        $query = $conn->prepare(
            "SELECT fr.subject_id,mf.name " .
            "FROM feature_relationship fr, feature f, feature mf " .
            "WHERE fr.subject_id=f.feature_id AND fr.object_id=mf.feature_id AND fr.object_id=$glass AND f.type_id=$polypeptide $organism;"
            );
        $query->execute();
        # update the polypeptides' name and uniquename values
        while (my @row = $query->fetchrow_array()) {
            my ($feature_id, $name) = @row;
            # if we successfully updated the feature
            $name .= "_pep";
            if ($conn->do("UPDATE feature SET name='$name', uniquename='$name' WHERE feature_id=$feature_id AND name NOT SIMILAR TO 'auto' AND uniquename NOT SIMILAR TO 'auto';")) {
                push(@sweet, $feature_id);
            }
            else {
                push(@sour, $feature_id);
            }
        }
    }
    # report how mny polypeptides were updated
    print "", scalar(@sweet), " polypeptides were succesfully updated\n", scalar(@sour), " failed to update\n";
}

# release variables and close the database connection
undef($query);
$conn->disconnect();

